{
  "title": "МАССИВЫ",
  "lessons": [
    {
      "title": "Зачем нужны массивы?",
      "items": [
        {
          "type": "text",
          "text": "Вернемся к нашим динозаврам. Положим, вы решили написать программу для учета всех видов динозавров, которые вам известны. Вы\nможете создать для каждого вида отдельную переменную:"
        },
        {
          "type": "code",
          "code": "var dinosaurl = \"Тираннозавр\";\nvar dinosaur2 = \"Велоцираптор\";\nvar dinosaur3 = \"Стегозавр\";\nvar dinosaur4 = \"Трицератопс\";\nvar dinosaur5 = \"Брахиозавр\";\nvar dinosaur6 = \"Птеранодон\";\nvar dinosaur7 = \"Апатозавр\";\nvar dinosaur8 = \"Диплодок\";\nvar dinosaur9 = \"Компсогнат\";"
        },
        {
          "type": "text",
          "text": "Однако пользоваться этим списком не слишком удобно — у вас\nесть девять переменных там, где можно обойтись лишь одной. А теперь\nпредставьте, что динозавров в программе не девять, а 1000! Пришлось\nбы создать 1000 отдельных переменных, работать с которыми было бы\nрешительно невозможно."
        },
        {
          "type": "image",
          "name": "3.1"
        },
        {
          "type": "text",
          "text": "Это похоже на список покупок, составленный так, что каждая\nпокупка указана на отдельном листе бумаги. На одном листке написано\n«яйца», на другом — «хлеб», на следующем — «апельсины». Большинство\nлюдей предпочли бы видеть весь список на одном листе бумаги. Так\nне проще ли сгруппировать всех динозавров в один список?\nВот для этого и нужны массивы.\n"
        }
      ]
    },
    {
      "title": "Создание массива",
      "items": [
        {
          "type": "text",
          "text": "Чтобы создать массив, используйте квадратные скобки [ ]. Фактически\nдля задания пустого массива достаточно лишь пары квадратных скобок. Но кому нужен пустой массив? Давайте-ка заполним его динозаврами!\nЧтобы создать массив со значениями, нужно перечислить эти значения внутри квадратных скобок, разделяя их запятыми. Отдельные значения, хранящиеся в массиве, называют элементами. В данном примере\nвсе элементы будут строковыми (это названия любимых динозавров),\nпоэтому запишем их в кавычках. Сохраним наш массив в переменной\nС именем dinosaurs:\n"
        },
        {
          "type": "code",
          "code": "var dinosaurs = [\"Тираннозавр\",\"Велоцираптор\",\"Стегозавр\",\"Трицератопс\",\"Брахиозавр\",\"Птеранодон\",\"Апатозавр\",\"Диплодок\",\"Компсогнат\"];\n"
        },
        {
          "type": "text",
          "text": "Длинный список сложно читать, когда он записан одной строкой, но, к счастью, это не единственный способ форматирования кода при соз­ дании массива. Вы можете поставить открывающую квадратную скобку на одной строке, каждый элемент писать с новой строки и последней строкой поставить закрывающую квадратную скобку:"
        },
        {
          "type": "code",
          "code": "var dinosaurs = [\n  \"Тираннозавр\",\n  \"Велоцираптор\",\n  \"Стегозавр\",\n  \"Трицератопс\",\n  \"Брахиозавр\",\n  \"Птеранодон\",\n  \"Апатозавр\",\n  \"Диплодок\",\n  \"Компсогнат\" \n];"
        },
        {
          "type": "text",
          "text": "Чтобы ввести такой код в консоли, вам придется нажимать одно­ временно с ENTER клавишу SHIFT каждый раз, когда нужно перейти к новой строке. Иначе JavaScript попытается выполнить то, что вы уже ввели, даже если команда еще не завершена. Поэтому при работе в кон­ соли проще записывать массивы одной строкой."
        },
        {
          "type": "text",
          "text": "Для JavaScript неважно, отформатируете вы код, расположив весь массив на одной строке или на нескольких строках по частям. Сколько бы ни стояло переносов, JavaScript увидит один и тот же массив — в нашем случае состоящий из девяти строк."
        }
      ]
    },
    {
      "title": "Доступ к элементам массива",
      "items": [
        {
          "type": "text",
          "text": "Чтобы получить доступ к элементам массива, используйте квадратные скобки с индексом нужного вам элемента, как в этом примере:"
        },
        {
          "type": "code",
          "code": "dinosaurs[0]; \n\"Тираннозавр\" \ndinosaurs[3]; \n\"Трицератопс\""
        },
        {
          "type": "text",
          "text": "Индекс — это номер элемента, в котором хранится значение. Аналогично символам в строке, первому элементу массива соответствует индекс 0, второму — 1, третьему — 2 и т. д. Поэтому, запросив индекс 0 в массиве dinosaurs, мы получили \"Тираннозавр\" (это первый эле­ мент), а запросив индекс 3 — \"Трицератопс\" (четвертый элемент)"
        },
        {
          "type": "text",
          "text": "Возможность доступа к отдельным элементам массива очень полез­ на. Например, если вы хотите показать кому-то самого-самого любимого своего динозавра, ни к чему показывать весь массив. Вместо этого про­ сто возьмите первый элемент:"
        },
        {
          "type": "code",
          "code": "dinosaurs[0]; \n\"Тираннозавр\""
        },
        {
          "type": "image",
          "name": "3.2"
        }
      ]
    },
    {
      "title": "Создание и изменение элементов",
      "items": [
        {
          "type": "text",
          "text": "Используя индекс в квадратных скобках, можно задавать или изме­ нять значения элементов и даже добавлять новые элементы. Например, чтобы заменить содержимое первого элемента массива dinosaurs (\"Тираннозавр\") на \"Тираннозавр реке\", можно написать:"
        },
        {
          "type": "code",
          "code": "dinosaurs [0] = \"Тираннозавр реке\";"
        },
        {
          "type": "text",
          "text": "После этого массив dinosaurs станет таким:"
        },
        {
          "type": "code",
          "code": "[\"Тираннозавр реке\", \"Велоцираптор\", \"Стегозавр\", \"Трицератопс\", \"Брахиозавр\", \"Птеранодон\", \"Апатозавр\", \"Диплодок\", \"Компсогнат\"]"
        },
        {
          "type": "text",
          "text": "С помощью индексов также можно добавлять в массив элементы. Например, вот как создать массив dinosaurs, задавая каждый элемент через квадратные скобки:"
        },
        {
          "type": "code",
          "code": "var dinosaurs = [];\ndinosaurs[0] = \"Тираннозавр\";\ndinosaurs[1] = \"Велоцираптор\";\ndinosaurs[2] = \"Стегозавр\";\ndinosaurs[3] = \"Трицератопс\";\ndinosaurs[4] = \"Брахиозавр\";\ndinosaurs[5] = \"Птеранодон\"; \ndinosaurs[6] = \"Апатозавр\";\ndinosaurs[7] = \"Диплодок\"; \ndinosaurs[8] = \"Компсогнат\";\n\ndinosaurs;\n\n[\"Тираннозавр\", \"Велоцираптор\", \"Стегозавр\", \"Трицератопс\", \n\"Брахиозавр\", \"Птеранодон\", \"Апатозавр\", \"Диплодок\", \"Компсогнат\"]"
        },
        {
          "type": "text",
          "text": "Сначала создаем пустой массив: var dinosaurs = [ ]. Затем в каждой из следующих строк добавляем по одному элементу кома­ дами dinosaurs[ ] с индексом от 0 до 8. Закончив наполнение мас­ сива, можно посмотреть его содержимое (набрав dinosaurs;) и убе­диться, что JavaScript расположил значения по порядку, в соответствии с индексами."
        }
      ]
    },
    {
      "title": "Разные типы данных в одном массиве",
      "items": [
        {
          "type": "text",
          "text": "Не обязательно, чтобы все элементы массива были одного типа. Например,\nвот массив, в котором хранится число (3), строка (\"динозавры\"), массив\n([\"трицератопс\", \"стегозавр\", 3627.5]) и еще одно число (10):\n"
        },
        {
          "type": "code",
          "code": "d i n o s a u r s A n d N u m b e r s [2];\n[\"трицератопс\", \"стегозавр\", 3627.5]\nd i n o s a u r s A n d N u m b e r s [ 2 ] [0];\n\" т рицератопс\"\n"
        },
        {
          "type": "image",
          "name": "3.3"
        },
        {
          "type": "text",
          "text": "Вводя d i n o s a u r s A n d N u m b e r s [2] [ 0 ] мы просим JavaScript обратиться к индексу 2 массива dinosaursA ndN um bers, где находится\nмассив [\"трицератопс\", \"стегозавр\", 3627.5], и вернуть значение с индексом 0 из этого вложенного массива — это первый элемент,\n\"трицератопс\". На рис. 3.1 показаны индексы для этих массивов.\n"
        }
      ]
    },
    {
      "title": "Работаем с массивами",
      "items": [
        {
          "type": "text",
          "text": "Работать с массивами вам помогут свойства и методы. Свойства хранят\nразличные сведения о массиве, а методы обычно либо изменяют его,\nлибо возвращают новый массив. Давайте разберемся."
        },
        {
          "type": "text",
          "text": "Длина массива"
        },
        {
          "type": "text",
          "text": "Порой нужно знать, сколько в массиве элементов. Например, если снова\nи снова добавлять динозавров в массив dinosaurs, вы можете забыть,\nсколько их теперь всего.\nДля этого есть свойство length (длина), хранящее количество элементов в массиве. Чтобы узнать длину массива, просто добавьте .length\nпосле его имени. Давайте посмотрим, как это работает. Но сначала создадим новый массив с тремя элементами:"
        },
        {
          "type": "code",
          "code": "var maniacs = [\"Якко\" , \"Вакко\", \"Дот\"];\nmaniacs [0];\n\"Якко\"\nmaniacs [1];\n\"Вакко\"\nmaniacs [2];\n\"Дот\""
        },
        {
          "type": "text",
          "text": "Чтобы узнать длину этого массива, добавим .l e n g t h к m aniacs:"
        },
        {
          "type": "code",
          "code": "maniac.length;\n3"
        },
        {
          "type": "text",
          "text": "JavaScript сообщает, что в массиве 3 элемента, и мы знаем, что их\nиндексы — 0, 1 и 2. Отсюда следует полезное наблюдение: последний\nиндекс массива всегда на единицу меньше длины этого массива. Это\nзначит, что есть простой способ получить последний элемент массива,\nкакой бы ни была его длина:"
        },
        {
          "type": "code",
          "code": "maniacs[maniacs.length - 1];\n\"Дот\""
        },
        {
          "type": "text",
          "text": "Мы попросили JavaScript вернуть элемент из нашего массива, но вместо числового индекса ввели в квадратных скобках выражение: длина\nмассива минус 1. JavaScript нашел свойство maniacs.length со значением 3, вычел 1, получив 2, и наконец вернул элемент с индексом 2 — это\nи есть последний элемент, \"Дот\"."
        },
        {
          "type": "text",
          "text": "Добавление элементов в массив"
        },
        {
          "type": "text",
          "text": "Чтобы добавить элемент к концу массива, можно воспользоваться методом push. Введите .push после имени массива, а после в круглых скобках укажите элемент, который нужно добавить:"
        },
        {
          "type": "code",
          "code": "vаr animals = [];\nanimals.push (\"Кот \" );\n1\nanimals.push (\"Пес\");\nanimals.push (\"Лама\");\n3\nanimals;\n[\"Кот\", \"Пес\", \"Лама\"]\nanimals.length;\n3\n"
        },
        {
          "type": "text",
          "text": "Командой v ar an im a ls = []; мы создали пустой массив anim als, а затем методом push добавили туда элемент\n\"Кот\". Потом снова использовали push, добавив \"Пес\",\nа затем \"Лама\". Запросив теперь содержимое массива\nanim als, мы видим, что \"Кот\", \"Пес\" и \"Лама\" стоят там\nв том же порядке, в каком мы их добавляли.\nЗапуск метода в программировании называется вызовом метода. При вызове метода push происходят две вещи.\nВо-первых, в массив добавляется элемент, указанный в скобках. Во-вторых, метод задает новую длину массива. Именно\nэти значения длины появляются в консоли после каждого\nвызова push.\nЧтобы добавить элемент в начало массива, используйте\nметод .unshift(элемент):\n"
        },
        {
          "type": "code",
          "code": "a n i m a l s ;\n[\"Кот\", \"Пес\", \"Лама\"]\na n i m a l s [0];\n\" Кот\"\na n i m a l s .u n s h i f t (\" М а р т ы ш к а \" );\n4\na n i m a l s ;\n[\"Мартышка\", \"Кот\", \"Пес\", \"Лама\"]\nanimals,u n sh ift(\"Белый медведь\");\n5\nanimals;\n[\"Белый медведь\", \"Мартышка\", \"Кот\", \"Пес\", \"Лама\"]\nanimals[0];\n\"Белый медведь\"\n0 animals[2];\n\" Ко т \"\n"
        },
        {
          "type": "text",
          "text": "Мы начали с массива, созданного раньше, —\n[\"Кот\", \"Пес\", \"Лама\"]. Затем добавили в его\nначало элементы \"Мартышка\" и \"Белый медведь\",\nотчего остальные элементы сдвинулись вперед —\nпри каждом добавлении их индексы увеличивались\nна 1. В результате элемент \"Кот\", у которого раньше\nбыл индекс О О, оказался под индексом 2 ©.\nКак и push, метод u n s h i f t при каждом вызове\nзадает новую длину массива.\n"
        },
        {
          "type": "text",
          "text": "Удаление элементов массива\n"
        },
        {
          "type": "text",
          "text": "Убрать из массива последний элемент можно, добавив к его имени\n.рор(). Метод pop делает сразу два дела: удаляет последний элемент\nиз массива и возвращает этот элемент в виде значения. Для примера\nначнем с нашего массива a n im als [\"Белый медведь\", \"Мартышка\",\n\"Кот\", \"Пес\", \"Лама\"]. Далее создадим новую переменную l a s t A n i m a l\nи сохраним в ней последний элемент, вызвав a n i m a l s . p o p ().\n"
        },
        {
          "type": "code",
          "code": "animals;\n[\"Белый медведь\", \"Мартышка\", \"Кот\", \"Пес\", \"Лама\"]\nО var lastAnimal = animalstpop() ;\nlastAnimal;\n\"Лама\"\nanimals;\n[\"Белый медведь\", \"Мартышка\", \"Кот\", \"Пес\"]\n© animals.pop() ;\n\"Пес\"\nanimals;\n[\"Белый медведь\", \"Мартышка\", \"Кот\"]\n© animals.u n sh ift(lastAnimal);\n4\nanimals;\n[\"Лама\", \"Белый медведь\", \"Мартышка\", \"Кот\"]\n"
        },
        {
          "type": "text",
          "text": "При вызове a n im a ls .p o p () в строке © последний элемент массива\na n im a ls, \"Лама\", был возвращен и сохранен в переменной la stA n im a l.\nКроме того, элемент \"Лама\" был удален из массива, в котором после\nэтого осталось четыре элемента. При следующем вызове a n i m a l s . p o p ()\nв строке © был удален из массива и возвращен элемент \"Пес\", а элементов в массиве осталось всего три.\nВызвав a n i m a l s .p o p () для элемента \"Пес\", мы не сохранили это\nзначение в переменной, и оно пропало. С другой стороны, элемент \"Лама\"\nбыл сохранен в переменной l a s t An i т а 1 , чтобы при случае им молено было\nснова воспользоваться. В строке © мы с помощью u n s h i f t ( l a s t A n i m a l )\nдобавили \"Лама\" обратно, в начало массива. В итоге получился массив\n[\"Лама\", \"Белыймедведь\", \"Мартышка\", \"Кот\"].\nМетоды push и pop хорошо друг друга дополняют, поскольку порой\nнужно работать только с концом массива. Вы можете добавить элемент\nвконец вызовом push, а потом, когда это понадобится, забрать его оттуда\nвызовом pop. Мы рассмотрим это на примере чуть позже в этой главе."
        },
        {
          "type": "image",
          "name": "3.4"
        },
        {
          "type": "text",
          "text": "Чтобы удалить из массива первый элемент, вернув его значение,\nиспользуйте . s h i f t ():\n"
        },
        {
          "type": "code",
          "code": "animals;\n[\"Лама\", \"Белый медведь\", \"Мартышка\", \"Кот\"]\nvar firstAnimal = animals.s h i f t ();\nfirstAnimal;\n\"Лама\"\nanimals;\n[\"Белый медведь\", \"Мартышка\", \"Кот\"]"
        },
        {
          "type": "text",
          "text": "Метод a n i m a l s , s h i f t () работает аналогично a n i m a l s . p o p (),\nно элемент берется из начала массива. В начале этого примера массив\nan im a ls имел вид [\"Лама\", \"Белый медведь\", \"Мартышка\", \"Кот\"].\nВызов . s h i f t ] ) вернул первый элемент, \"Лама\", который мы сохранили\nв переменной firstA nim al. Поскольку .s h i f t |) не только возвращает\nэлемент, но и удаляет его, в массиве a n im als осталось лишь [\"Белый\nмедведь\", \"Мартышка\", \"Кот\"].\nМетоды u n s h i f t и s h i f t добавляют и удаляют элементы с начала\nмассива — так же как pu s h и р о р добавляют и удаляют элементы с конца."
        },
        {
          "type": "image",
          "name": "3.5"
        },
        {
          "type": "text",
          "text": "Объединение массивов"
        },
        {
          "type": "text",
          "text": "Чтобы «склеить» два массива, создав таким образом\nновый массив, используйте команду firstA rray.\nconcat(otherA rray). Метод concat создает массив, в котором элементы из firstA rray будут расположены перед элементами из otherA rray.\nПускай у нас есть два списка — список\nпушистых животных и список чешуйчатых\nживотных — и мы хотим их объединить. Если\nпоместить наших пушистых животных в массив fu rry A n im a ls, а чешуйчатых — в массив scalyA nim als, команда fu rry A n im a ls.\nc o n c a t ( s c a l y A n i m a l s ) создаст новый массив,\nв начале которого будут элементы из первого массива, а в конце — из второго.\n"
        },
        {
          "type": "code",
          "code": "vаг furryAnimals = [\"Альпака\", \"Кольцехвостый лемур\", \"Йети\"];\nvar scalyAnimals = [\"Удав\", \"Годзилла\"];\nyar furryAndScalyAnimals = furryAnimals.concat(scalyAnimals);\nfurryAndScalyAnimals;\n[\"Альпака\", \"Кольцехвостый лемур\", \"Йети\", \"Удав\", \"Годзилла\"]\nfurryAnimals;\n[\"Альпака\", \"Кольцехвостый лемур\", \"Йети\"]\nscalyAnimals;\n[\"Удав\", \"Годзилла\"]\n"
        },
        {
          "type": "text",
          "text": "Хоть команда firstA rra y .c o n c a t(o th e rA rra y ) и возвращает массив, содержащий все элементы из firstA rra y и otherA rray, сами эти\nмассивы остаются прежними. Запросив содержимое fu rry A n im a ls\nи scalyA nim als, мы видим, что массивы не изменились."
        },
        {
          "type": "text",
          "text": "С помощью co n c at можно объединить больше чем два массива. Для этого\nукажите дополнительные массивы в скобках, разделив их запятыми:\n"
        },
        {
          "type": "code",
          "code": "var furryAnimals = [\"Альпака\", \"Кольцехвостый лемур\", \"Йети\"];\nvar scalyAnimals = [\"Удав\", \"Годзилла\"];\nvar featheredAnimals = [\"Ара\", \"Додо\"];\nvar allAnimals = furryAnimals . concat ( scalyAnimals, «-* 1\nfeatheredAnimals);\nallAnimals;\n[\"Альпака\", \"Кольцехвостый лемур\", \"Йети\", \"Удав\", \"Годзилла\",\n\"Ара\", \"Додо\"]\n"
        },
        {
          "type": "text",
          "text": "Мы видим, что пернатые животные из массива fe a th e re d A n im a ls\nоказались в самом конце нового массива, поскольку fe a th e re d A n im a ls\nбыл указан последним в скобках метода concat.\nМетод co n c at удобен, когда нужно объединить несколько массивов\nв один. Скажем, пусть у вас есть список любимых книг и у вашего друга\nтоже есть свой список, и вы решили выяснить, можно ли купить все эти\nкниги в магазине по соседству. Тогда будет проще, если у вас будет не два\nсписка, а один. Просто объедините ваш список со списком вашего друга\nметодом concat, и пожалуйста — у вас один список на двоих!\n"
        },
        {
          "type": "text",
          "text": "Поиск индекса элемента в массиве"
        },
        {
          "type": "text",
          "text": "Чтобы выяснить, какой у определенного элемента индекс в массиве, используйте .in d e x O f(\"элемент\"). Создадим массив co lo rs\nс названиями цветов, а затем получим индексы элементов «синий»\nи «зеленый» с помощью команд c o l o r s . i n d e x O f ( \" с и н и й \" ) и colors.\ni n d e x O f ( \" з е л е н ы й \" ) . Поскольку \"синий\" располагается по индексу 2,\nc o l o r s . i n d e x O f ( \" с и н и й \" ) вернет 2. А \"зеленый\" находится по индексу 1, так что c o l o r s . i n d e x O f ( \" з е л е н ы й \" ) вернет 1.\n"
        },
        {
          "type": "code",
          "code": "var colors = [\"красный\", \"зеленый\", \"синий\"];\ncolors,indexOf(\"синий\");\ncolors,indexOf(\"зеленый\");\n1"
        },
        {
          "type": "text",
          "text": "Чтобы удалить из массива первый элемент, вернув его значение,\nиспользуйте . s h i f t ():\n"
        },
        {
          "type": "text",
          "text": "Метод indexOf похож на квадратные скобки, только здесь все наоборот: команда colors[2] вернет \"синий\", a c o l o r s . i n d e x O f ( \" с и н и й \" )\nвернет 2."
        },
        {
          "type": "code",
          "code": "c o l o r s [2];\n\"синий\"\ncolors.indexOf(\"синий\");\n2"
        },
        {
          "type": "text",
          "text": "Хотя элемент \"синий\" стоит третьим по порядку, его индекс равен 2,\nведь мы всегда считаем с 0. Разумеется, то же относится к \"зеленый\"\nс индексом 1.\nЕсли элемента, индекс которого вы запрашиваете, в массиве нет,\nJavaScript вернет значение —1."
        },
        {
          "type": "code",
          "code": "colors.indexOf(\"фиолетовый\");\n-1"
        },
        {
          "type": "text",
          "text": "Таким образом JavaScript сообщает: «элемент не найден», так или\nиначе возвращая из метода число.\nЕсли элемент встречается в массиве больше чем один раз, indexO f\nвернет индекс того элемента, который находится ближе к началу массива."
        },
        {
          "type": "code",
          "text": "var insects = [\"Пчела\", \"Муравей\", \"Пчела\", \"Пчела\", \"Муравей\"];\ninsects.indexOf(\"Пчела\");\n0\n"
        },
        {
          "type": "text",
          "text": "Превращаем массив в строку\n"
        },
        {
          "type": "text",
          "text": "Воспользовавшись методом .join(), можно соединить все элементы\nмассива в одну большую строку.\n"
        },
        {
          "type": "code",
          "text": "var boringAnimals = [\"Мартышка\", \"Кот\", \"Рыба\", \"Ящерица\"];\nboringAnimals.j o i n () ;\n\"Мартышка,К от,Рыба,Ящерица\"\n"
        },
        {
          "type": "text",
          "text": "Метод join возвращает строку, в которой через запятую перечислены все элементы массива boringA nim als, Но что если мы не хотим\nиспользовать в качестве разделителя запятую?\nНам поможет метод .jo in (\"разделитель\"), который делает все\nто же самое, но вместо запятых ставит между элементами выбранный\n разделитель. Давайте попробуем три разных разделителя:\nдефис с пробелами по сторонам, звездочку * и союз «и»\nс пробелами по сторонам. Обратите внимание: разделитель\nнужно записывать в кавычках — ведь это строка."
        },
        {
          "type": "code",
          "text": "var boringAnimals = [\"Мартышка\", \"Кот\", \"Рыба\", \"Ящерица\"];\nboringAnimals.j o i n (\" - \");\n\"Мартышка - Кот - Рыба - Ящерица\"\nboringAnimals.j o i n (\"*\")\n\"Мартышка'* Кот* Рыба*Ящерица\"\nboringAnimals . j oin ( \" и \" J.\n\"Мартышка и Кот и Рыба и Ящерица\"\n"
        },
        {
          "type": "text",
          "text": "Этот вариант jo in удобен, когда у вас есть массив, из которого нужно\nсделать строку. Предположим, у вас много средних имен и вы решили\nхранить их все в массиве вместе со своим личным именем и фамилией.\nИ вдруг кому-то понадобилось ваше полное имя в виде строки. Тогда\nметод jo in с разделителем-пробелом преобразует все имена в искомую\nстроку:"
        },
        {
          "type": "code",
          "text": "var myNames = |[\"Николас'', \"Эндрю\", \"Максвелл\", \"Морган\" ] ;\nm y N ames.j o i n (\" \");\n\"Николас Эндрю Максвелл Морган\"\n"
        },
        {
          "type": "text",
          "text": "Не будь метода jo in , пришлось бы соединять элементы вручную,\nчто очень утомительно:\n"
        },
        {
          "type": "code",
          "text": "myNames[0] + \" \" + myNames[l] + \" \" + myNames [2] + \" \" + myNames [3] ;\n\"Николас Эндрю Максвелл Морган\"\n"
        },
        {
          "type": "text",
          "text": "Кроме того, этот код сработает, только если у вас ровно два средних\nимени. Если же их три или одно, программу придется менять. A c j o i n\nничего менять не надо — этот метод соединит в строку все элементы\nмассива независимо от его длины.\nЕсли же в массиве хранятся нестроковые значения, JavaScript преобразует их в строки перед тем, как соединить:\n"
        },
        {
          "type": "code",
          "text": "var ages = [11, 14, 79];\nage s .j o i n (\" \");\n\"11 14 79\""
        }
      ]
    },
    {
      "title": "Что полезного можно сделать с массивами",
      "items": [
        {
          "type": "text",
          "text": "Теперь вы умеете разными способами создавать массивы и знаете немало\nдействий с ними. Но как все это может вам пригодиться в жизни? В этом\nразделе мы разберем несколько коротких программ, посвященных практическому использованию массивов.\n"
        },
        {
          "type": "Поиск дороги домой",
          "text": "Представьте, что ваша подруга побывала у вас в гостях, а теперь хочет\nпоказать вам свой дом. Но вот незадача — вы никогда не бывали у нее\nраньше, а путь назад вам предстоит проделать в одиночку.\nК счастью, вам в голову приходит хитрый способ решения этой проблемы: по дороге к дому подруги вы будете записывать возможные ориентиры (телефонную будку, вывеску магазина или аптеки, школу и т. д.).\nА по дороге назад, двигаясь по списку с конца, вычеркивать каждый\nвстреченный ориентир — так вы всегда будете знать, куда идти дальше"
        },
        {
          "type": "text",
          "text": "Представьте, что ваша подруга побывала у вас в гостях, а теперь хочет\nпоказать вам свой дом. Но вот незадача — вы никогда не бывали у нее\nраньше, а путь назад вам предстоит проделать в одиночку.\nК счастью, вам в голову приходит хитрый способ решения этой проблемы: по дороге к дому подруги вы будете записывать возможные ориентиры (телефонную будку, вывеску магазина или аптеки, школу и т. д.).\nА по дороге назад, двигаясь по списку с конца, вычеркивать каждый\nвстреченный ориентир — так вы всегда будете знать, куда идти дальше"
        },
        {
          "type": "code",
          "text": "var landmarks = [];\nlandmarks.push(\"Мой дом\");\nlandmarks.push(\"Дорожка к дому\");\nlandmarks.push(\"Мигающий фонарь\");\nlandmarks.push(\"Протекающий гидрант\");\nlandmarks.push(\"Пожарная станция\");\nlandmarks.push(\"Приют для кошек\");\nlandmarks.push(\"Моя бывшая школа\");\nlandmarks.push(\"Дом подруги\");\n"
        },
        {
          "type": "text",
          "text": "Здесь мы создали пустой массив landm arks и методом push сохранили в нем все ориентиры, замеченные по дороге к дому подруги. Вы добрались до дома подруги, и можно изучить массив ориентиров.\nРазумеется, первым стоит \"Мой дом\", потом \"Дорожка к дому\", и т. д.\nдо конца массива, где находится элемент \"Дом подруги\". Теперь, когда\nнаступит время идти домой, вам останется лишь изымать из массива\nпо одному элементу, и всегда будет понятно, куда идти дальше.\n"
        },
        {
          "type": "code",
          "text": "landmarks.pop();\n\"Дом подруги\"\nlandmarks.pop();\n\"Моя бывшая школа\"\nlandmarks.pop();\n\"Приют для кошек\"\nlandmarks.pop();\n\"Пожарная станция\"\nlandmarks.pop();\n\"Протекающий гидрант\nlandmarks.pop();\n\"Миг ающий фонарь\"\nlandmarks.pop();\n\"Дорожка к дому\"\nlandmarks.pop();\n\"Мой дом\"\n"
        },
        {
          "type": "text",
          "text": "Вот вы и дома!\nЗаметили, что первый ориентир, который вы поместили\nв массив методом push, оказался также последним, который\nвы извлекли методом pop? А последний добавленный ориентир\nоказался первым извлеченным? Может показаться, что лучше\nбы первый добавленный элемент и извлекался всегда первым,\nоднако извлекать элементы в обратном порядке в некоторых\nслучаях удобно.\nТакой подход нередко используется в больших программах — именно поэтому p u sh и pop в JavaScript всегда под\nрукой.\n"
        },
        {
          "type": "text",
          "text": "Среди программистов такой способ работы с элементами называется «стек». Представьте, что стек — это стопка блинов. Всякий\nраз, когда готов новый блин, его кладут сверху стопки (какметод\npush), и, когда вы берете блин, чтобы его съесть, вы тоже берете\nего сверху (какметод pop). Снятие элементов со стека похоже\nна путешествие назад во времени: последним изымается элемент, который был в стеке первым. То же происходит с блинами:\nпоследний блин, который вы съедите, — это первый, который был\nприготовлен. На сленге программистов этот способ называется\n«последним вошел, первым вышел», английская аббревиатура LIFO\n(last in, first out). Есть и альтернативный подход — «первым вошел,\nпервым вышел», аббревиатура FIFO (first in, first out). Его также\nназывают очередью, поскольку таким же образом устроены очереди — первый человек, вставший в очередь, будет первым, которого обслужат."
        },
        {
          "type": "text",
          "text": "Случайный выбор"
        },
        {
          "type": "text",
          "text": "Используя массивы, молено написать программу, которая выдает случайные варианты из заданного списка (наподобие «шара судьбы»). Однако\nсначала нужно разобраться, откуда нам брать случайные числа.\n Случайные числа можно генерировать с помощью специального метода\nM a th .ra n d o m O , который при каждом вызове возвращает случайное\nчисло от 0 до 1:\n"
        },
        {
          "type": "code",
          "text": "Math.random()\n0.35360684572237533\nMath.random()\n0.3111661787729043\nMath.random()\n0.4370192384482239"
        },
        {
          "type": "text",
          "text": "Важно помнить, что M a th .ran d o m O всегда возвращает число\nменьше 1, то есть никогда не возвращает собственно 1.\nЕсли вам нужно число побольше, просто умножьте полученное из метода M ath.random O значение на подходящий коэффициент. Например,\nесли нужно случайное число от 0 до 10, умножьте M a th , r a n d o m f) на 10:\n"
        },
        {
          "type": "code",
          "text": "M a t h .rand o m () * 10;\n7.648027329705656\nM a t h . rand o m ( ) *■ 10;\n9.7565904534421861\nM a t h . rand o m ( ) *■ 10;\n0.21483442978933454"
        },
        {
          "type": "text",
          "text": "И все же эти случайные значения нельзя использовать как индексы\nв массиве, поскольку индексы должны быть целыми числами, а не десятичными дробями. Чтобы исправить этот недостаток, нужен метод\nM a th .f lo o r (), округляющий число до ближайшего снизу целого значения (по сути, он просто отбрасывает все знаки после запятой).\n"
        },
        {
          "type": "code",
          "text": "M a t h .f l oor(3.7463463);\n3\nM a t h .f l oor(9.9999);\n9\nM a t h .floor(0.793423451963426);\n0\n"
        },
        {
          "type": "text",
          "text": "Давайте используем оба метода, чтобы получить случайный индекс.\nНужно лишь умножить M a th , r a n d o m () на длину массива и затем округлить полученное число методом M a t h . f lo o r (). Например, если в массиве\nчетыре элемента, это можно сделать так:\n"
        },
        {
          "type": "code",
          "text": "M a t h .floor(Math.r a n d o m () * 4);\n2 // может выпасть 0, 1, 2 или 3"
        },
        {
          "type": "text",
          "text": "При каждом запуске этот код будет возвращать случайное число от О\nдо 3 (включая 0 и 3). Поскольку Mat h. г a ndom() всегда возвращает значение меньше 1, Mat h . г a ndom () *4 никогда не вернет 4 или большее число.\nИспользуя это случайное число как индекс, можно получить случайный элемент массива:"
        },
        {
          "type": "code",
          "text": "var randomWords = [\"Взрыв\", \"Пещера\", \"Принцесса\", \"Карандаш\"];\nvar randomlndex = Math.floor(Math.random() * 4);\nrandomWords[randomlndex];\n\"Пещера\"\n"
        },
        {
          "type": "text",
          "text": "С помощью M a t h .f l o o r ( M a t h . r a n d o m ( ) * 4); мы получили случайное число от 0 до 3. Сохранив это число в переменной ra n d o m ln d e x , мы\nиспользовали его как индекс для получения строки из массива randomW ords.\nВ сущности, можно сделать этот код короче, избавившись от переменной ra n d o m ln d e x :\n"
        },
        {
          "type": "code",
          "code": "randomWords[Math.floor(Math.rand o m () * 4)];\n\"Принцесса\"\n"
        },
        {
          "type": "text",
          "text": "Теперь давайте создадим массив с фразами, чтобы случайным образом\nвыбирать их с помощью написанного ранее кода. Это и будет наш компьютерный «шар судьбы»! В комментариях указаны примеры вопросов,\nкоторые можно задать нашей программе.\n"
        },
        {
          "type": "code",
          "text": "var phrases = [\n\"Звучит неплохо\",\n\"Да, это определенно надо сделать\",\n\"Не думаю, что это хорошая идея\",\n\"Может, не сегодня?\",\n\"Компьютер говорит нет\"\nз*\n/ / Мне выпить еще молочного коктейля?\nphrases[Math.floor(Math.rand o m () * 5)];\n\"He думаю, что это хорошая идея\"\n// Мне пора делать домашнюю работу?\nphrases[Math.floor(Math.rand o m () * 5)1;\n\"Может, не сегодня?\"\n"
        },
        {
          "type": "text",
          "text": "Мы создали массив p h r a s e s , в котором хранятся различные советы.\nТеперь, придумав вопрос, можно запросить случайный элемент из массива p h r a s e s , и полученный совет поможет принять решение!\nОбратите внимание: поскольку в массиве с советами пять элементов,\nмы умножаем M a th .ran d o m O на 5. Таким образом, мы всегда получим\nодно из пяти значений индекса: 0, 1, 2, 3 или 4."
        },
        {
          "type": "text",
          "text": "Генератор случайных дразнилок"
        },
        {
          "type": "text",
          "text": "Можно усовершенствовать код выбора вариантов, создав программу,\nкоторая при каждом запуске генерирует случайную дразнилку!\n"
        },
        {
          "type": "code",
          "text": "var randomBodyParts = [\"глаз\", \"нос\", \"череп\"];\nvar randomAdjectiyes = [\"вонючая\", \"унылая\", \"дурацкая\"];\nvar randomWords = [\"муха\", \"выдра\", \"дубина\", \"мартышка\", \"крыса\"];\n// Выбор случайной части тела из массива randomBodyParts:\nО var randomBodyPart = randomBodyParts[Math.floor(Math.random() * 3)];\n/./ Выбор случайного прилагательного из массива randomAdjestivesг\n© var randomAdj ective = randomAdj ectives[Math.floor(Math.random() * 3)];\n// Выбор случайного слова из массива randomWords:\n© var randomWord = randomWords [Math, floor (Math, random( ) 5)];\n// Соединяем случайные строки в предложение:\nvar randomlnsult = \"У тебя \" + randomBodyPart + \" словно \" +\nrandomAdjective + \" \" + randomWord + \"!!!\";\nrandomlnsult;\n\"У тебя нос словно дурацкая выдра!!!\""
        },
        {
          "type": "text",
          "text": "У нас есть три массива со словами, и в строках 5, 7 и 9 мы с помощью трех индексов берем из каждого массива по случайному слову. Затем мы склеиваем их, помещая\nрезультат в переменную r a n d o m l n s u lt, —\nэто и есть готовая дразнилка. В строках 5\nи 7 мы используем множитель 3, поскольку\nи в r a n d o m A d j e c t i v e , и в ra n d o m B o d y P a rt\nпо три элемента. Аналогично в строке 9 мы\nумножаем на 5, ведь в random W ords пять\nэлементов. Обратите внимание, что мы добавили между r a n d o m A d j e c t i v e и random W ord строку с единственным пробелом. Запустите этот код несколько раз —\nпри каждом запуске получится новая случайная дразнилка!\n"
        }
      ]
    },
    {
      "title": "Что мы узнали",
      "items": [
        {
          "type": "text",
          "text": "Как мы теперь знаем, массивы JavaScript предназначены для хранения\nсписка значений. Мы научились создавать массивы и работать с ними\nи освоили много способов доступа к их элементам.\nМассивы JavaScript — один из способов хранения множества значений\nв одном месте. В следующей главе мы познакомимся с объектами — другим способом объединения значений в единую сущность. Для доступа\nк элементам объектов используются строковые ключи, а не индексы."
        }
      ]
    },
    {
      "title": "УПРАЖНЕНИЯ",
      "items": [
        {
          "taskId": 31,
          "type": "task",
          "task": "C помощью метода join превратите массив [3, 2, 1] в строку \"3 больше, чем 2 больше, чем 1\"",
          "solution": "3 больше, чем 2 больше, чем 1",
          "solutionCode": "[3,2,1].join(' больше, чем ')"
        },
        {
          "taskId": 32,
          "type": "task",
          "task": "Усовершенствуйте генератор дразнилок, чтобы он создавал драз­ нилки такого типа: «У тебя [часть тела] еще более [прилагатель­ ное], чем [часть тела животного] у [животное]».\nПодсказка: нужно будет создать еще один массив.",
          "solution": ""
        }
      ]
    }
  ]
}
